# 面试题整理
**from[简书文章](https://www.jianshu.com/p/c70989bd5f29)**

## 一、java面试题

### （一） java基础面试知识点
* **java中==和equals和hashCode的区别**

	基本数据类型的==比较的值相等. </br>
	类的==比较的内存的地址，即是否是同一个对象，在不覆盖equals的情况下，同比较内存地址，原实现也为 == ，如String等重写了equals方法.</br>
	hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等比较是否为同一个）</br>
	1. 如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 
	2. 如果两个对象不equals，他们的hashcode有可能相等。 
	3. 如果两个对象hashcode相等，他们不一定equals。 
	4. 如果两个对象hashcode不相等，他们一定不equals。
	
* **int、char、long各占多少字节数**

	TYPE | BYTE | BIT
	------|----|-------|
	int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float | 4 byte  |32 bit
	short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char|2 byte|16 bit
	double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long|8 byte|64 bit

	
	
* **int与integer的区别**

	int 基本类型 </br>
	integer 对象 int的封装类
	
* **谈谈对java多态的理解**
	
	继承、重写、向上转型
	</br>实现多态形式：继承和接口
	
	1. 使用父类类型的引用指向子类的对象；

	2. 该引用只能调用父类中定义的方法和变量；

	3. 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;

* **String、StringBuffer、StringBuilder区别**
	
	String:字符串常量 不适用于经常要改变值得情况，每次改变相当于生成一个新的对象</br>
	StringBuffer:字符串变量 （线程安全）</br>
	StringBuilder:字符串变量（线程不安全） 确保单线程下可用，效率略高于StringBuffer
	
* **什么是内部类？内部类的作用**
	
	内部类可直接访问外部类的属性</br>
	Java中内部类主要分为**成员内部类**、**局部内部类**(嵌套在方法和作用域内)、**匿名内部类**（没构造方法）、**静态内部类**（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）
	
* **抽象类和接口区别**
	
	均不能被实例化 不能直接实例化 多态实例化其子类</br>
	接口抽象级别高于抽象类</br>
	接口只能声明方法，抽象类既可以声明方法也可以实现方法</br>
	抽象类内可以没有抽象方法,抽象方法不能是静态以及私有的</br>
	抽象类单继承 接口多实现</br>
	接口内可含不可变常量，之前没用过。但将常量变量放在interface中违背了其作为接口的作用而存在的宗旨，也混淆了interface与类的不同价值。</br>
	
* **抽象类的意义**

	我们再开始使用的时候就是用的接口，后来实现的子类里有些子类有共同属性，或者相同的方法实现，所以提取出来一个抽象类，作为类和接口的中介。</br>
	只有抽象类没有抽象对象
	
* **抽象类是否可以没有方法和属性？**
	
	可以
	
* **泛型中extends和super的区别**

	<? super T>表示包括T在内的任何T的父类 下界通配符</br><? extends T>表示包括T在内的任何T的子类 上界通配符
	
* **父类的静态方法能否被子类重写**

	可被继承 不能被重写</br>
	静态方法从程序开始运行后就已经分配了内存,子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法。
	
* **进程和线程的区别**

	进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</br>
	进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。</br>
	一个进程内可拥有多个线程，进程可开启进程，也可开启线程。</br>
	一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。
	
* **final，finally，finalize的区别**

	final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写</br>
	finally:与try...catch...共同使用，确保无论是否出现异常都能被调用到</br>
	finalize:类的方法,垃圾回收之前会调用此方法,子类可以重写finalize()方法实现对资源的回收
	
* **序列化的方式**

	static、trasient修饰的变量不可被序列化</br>
	若一个类可序列化，其子类，内部类都要可序列化</br>
	序列化的定义：任何数据都是以二进制的形式存贮到硬盘或是在网络上传送，而Java为了能将Java对象存贮到硬盘上或在网络上传送，把Java对象转换成字节流进行传输，这个转换过程就称之为Java序列化。Java --> 二进制字节流。

* **Serializable 和Parcelable 的区别**

	Serializable Java 序列化接口 在硬盘上读写 读写过程中有大量临时变量的生成</br>
	Parcelable Android 序列化接口 效率高 使用麻烦 在内存中读写（AS有相关插件 一键生成所需方法）
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fodg2vz29sj30lw0fkwfp.jpg)

* **静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？**

	可继承 不可重写 而是被隐藏</br>
	如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成。

* **静态内部类的设计意图**

	降低包的深度，方便类的使用，不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。</br>
	普通内部类拥有外部类的指针，可以随意使用外部类的变量及方法。生成实例时需先生成外部类的实例。
	
* **成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用**

	Java中内部类主要分为**成员内部类**、**局部内部类**(嵌套在方法和作用域内)、**匿名内部类**（没构造方法）、**静态内部类**（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）</br>
	
	使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</br>
	因为Java不支持多继承，支持实现多个接口。但有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。

		
* **谈谈对kotlin的理解**

	kotlin是对java的一层包装，语法接近于函数式编程，基于JVM设计,100%兼容Java,切换成本小。两种代码可并存，互相调用，互相转换。
	* null 安全</br>
	* lambda 方便进行函数式编程</br>
	* 流式API
	*  ...

* **闭包和局部内部类的区别**

	闭包能够将一个方法作为一个变量去存储，这个方法有能力去访问所在类的自由变量。
	
	闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。
	
	在Java中，闭包是 通过“接口与内部类实现的”
	
* **String 转换成 Integer的方式及原理**
	
	String --> Integer
```java
	String str = "...";
	Integer i = null;
	if(str!=null){
    		i = Integer.valueOf(str);
	}
```
Integer --> String


 ```java
Integer a = 2;
String str = Integer.toString(a)
```	
	
```java
Integer a = 2;
String str = a.toString();
```
	
```java
Integer a = 2;
String str = String.valueOf(a);
```
